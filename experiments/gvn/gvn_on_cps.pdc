%GVN on CPS
%
%

<!-- TODO: bib, cites -->

Global Value Numbering (GVN) is an optimisation algorithm that takes advantage
of the Single Static Assignment (SSA) form to improve on Value Numbering.

Continuation Passing Style (CPS) is a special form of $\lambda$-calculus where
functions get a continuation argument to be used instead of returning. As was
exposed by TODO:cite, SSA and CPS can be translated into each other.

We here present a translation of the GVN algorithm to CPS.

#Notations

The BNF grammar of CPS terms is:

\begin{equation}
\begin{array}{r l}
m ::= & | \: f \: v_1 \: \dots \: v_n \: k\\
      & | \: l \: v_1 \: \dots \: v_n\\
      & | \: if(v) \: then \:
               l_1 \: v_1 \: \dots \: v_n \:
             else \:
               l_2 \: u_1 \: \dots \: u_n\\
      & | \: let \: x \: = \: v \: in \: m\\
      & | \: let \: rec \: f_1 \: = \: \lambda_j \: x_1 \: \dots \: x_{n1} \: . \: m_1 \:
                    and \: \dots \:
                    and \: f_n \: = \: \lambda_j \: x_1 \: \dots \: x_{nn} \: . \: m_n \:
             in \: m\\
k ::= & | \: l\\
      & | \: \lambda_c \: x \: . \: m\\
v ::= & | \: x\\
      & | \: 0 \: | \: 1 \: | \: \dots\\
      & | \: v_1 \: + \: v_2\\
      & | \: v_1 \: \times \: v_2\\
      & | \: \dots\\
\end{array}
\end{equation}

where $f$, $l$, $x$, and $y$ are variables. Also note that $\lambda$s are
annotated with either $c$ for continuations, $j$ for jumps, and $p$ for
procedures (not shown here. These annotations are for compilation purpose: TODO:
explain.

The corresponding OCaml type is:

    type m =
      | Mapp  of (var * value list * continuation)
      | Mcont of (var * value list)
      | Mif   of (value * (var * var list) * (var * var list))
      | Mlet  of (var * value * m)
      | Mrec  of ((var * var list * m) list * m)
    and continuation =
      | Cvar of var
      | C    of (var * m)
    and value =
      | Vvar of var
      | Vcst of int
      | Vadd of (value * value)
      | Vmul of (value * value)
      | ..

The notion of primitive operators (addition, multiplication) is purposedly left
unspecified but should be such as no function calls are made.

##About SSA to CPS translation

Here is a correspondence table for SSA to and from CPS translation:

+-------------------------------------+----------------------------------------+
| SSA                                 | CPS                                    |
+=====================================+========================================+
| Procedure                           | Lambda ($\lambda_p$)                   |
+-------------------------------------+----------------------------------------+
| Basic Block                         | Lambda ($\lambda_j$)                   |
+-------------------------------------+----------------------------------------+
| Jump                                | Call                                   |
+-------------------------------------+----------------------------------------+
| Branch                              | If-Then-Else                           |
+-------------------------------------+----------------------------------------+
| Return                              | Continuation Call                      |
+-------------------------------------+----------------------------------------+

Here is are other important things to keep in mind:

- the dominance tree of the SSA CFG is directly reflected in the term structure
  of the CPS term,
- $\lambda$s are annotated with either `j`, `c`, or `p` to denote, respectively,
  jumps, continuations, or procedure call.



##Notions

We define the following:

Calls <!-- TODO: rewrite with LAMBDAS -->
:   the calls that are made in a CPS term

    \begin{equation}
    \begin{array}{r l}
    Calls(f \: v_1 \: \dots \: v_n \: k) = & Calls_k(k) \\
    Calls(l \: v_1 \: \dots \: v_n) = & \{ l \} \\
    Calls(if(v) \: then \: l_1 \: v_1 \: \dots \: v_n \: else \: l_2 \: u_1 \: \dots \: u_n) = &
      \{ l1, \: l2 \}\\
    Calls(let \: x \: = \: v \: in \: m) = & Calls(m) \\
    Calls(let \: rec \: f_1 \: = \: \lambda_j \: x_1 \: \dots \: x_{n1} \: . \: m_1 \:
                 and \: \dots \:
                 and \: f_n \: = \: \lambda_j \: x_1 \: \dots \: x_{nn} \: . \: m_n \:
          in \: m) = & Calls(m) \cup \bigcup_{1 < i < n} Calls(m_i)\\
    Calls_k(l) = & \{ l \} \\
    Calls_k(\lambda_c \: x \: . \: m) = & Calls(m) \\
    \end{array}
    \end{equation}

    <!-- foobar -->

        let rec calls = function
          | Mapp  (_, _, Cvar k     ) -> [k]
          | Mapp  (_, _, C    (_, m)) -> calls m
          | Mcont (k, _) -> [k]
          | Mif   (_, (k1, _), (k2, _)) -> [k1; k2]
          | Mlet  (_, _, m) -> calls m
          | Mrec  (ls, m) -> calls m :: List.map (fun (_, _, m) -> calls m) ls

Note that we assume that names are unique (and thus that a function and its name
can be associated). This is a cheap assumption because the context ensures that
functions are named after SSA block labels (which need be unique).


$Children$
:   list all the strict sub-terms of a term

        let rec children = function
          | Mapp  (_, _, Cvar _     ) -> []
          | Mapp  (_, _, C    (_, m)) -> [m]
          | Mcont (_, _) -> []
          | Mif   (_, (_, _), (_, _)) -> []
          | Mlet  (_, _, m) -> [m]
          | Mrec  (ls, m) -> m :: List.map (fun (_, _, m) -> m) ls

$Parent$
:   TODO

$Parents$
:   TODO


#GVN on CPS

##Code Modifications

Just as with the original GVN algorithm, the code needs to be (automatically)
modified. The three modifications that we apply are:

- landing lambdas insertion,
- call splitting, and
- virtual call annotation.

### Landing Lambdas

GVN introduces landing lambdas at the entrance of each loop. These landing pads
allow to move code from \`\`after'' the loop to \`\`before'' it. We call the
corresponding concept in CPS *landing lambdas*.

Simple loop header:
:   `l` is a simple loop header when it is part of

        let rec simple_loop_headers = function
          | Mapp  (_, _, Cvar _     ) -> []
          | Mapp  (_, _, C    (_, m)) -> simple_loop_headers m
          | Mcont (_, _) -> []
          | Mif   (_, (_, _), (_, _)) -> []
          | Mlet  (_, _, m) -> simple_loop_header m
          | Mrec  (ls, m) ->
            simple_loop_headers m
            :: List.fold_left
                 (fun a (l, _, m) -> if List.mem l (calls m) then l :: a else a)
                 []
                 ls


Simple loop headers are the entry nodes of loops that have exactly one entry
node. Such loops are of two kind: while-loops and other loops. While the former
is not straightforward, the latter is trivial to equip with a landing lambda:

    let rec add_landing_lambdas = function
      | Mapp  (_, _ , Cvar _     ) as m -> m
      | Mapp  (f, vs, C    (x, m))      -> Mapp (f, vs, C (x, add_landing_lambdas m))
      | Mcont (_, _) as m -> m
      | Mif   (_, (_, _), (_, _)) as m -> m
      | Mlet  (x, v, m) -> Mlet  (x, v, add_landing_lambdas m)
      | Mrec  (ls, Mif (v, (k1, vs1), (k2, vs2))) when is_while_loop ls k1 k2 ->
        TODO
      | Mrec  (ls, m) ->
        Mrec (
          List.map
            (fun (l, vs, m) ->
             if is_other_loop l m then
               let f = fresh_var () in
               (l, vs, (Mrec ([(f, vs, subs l f m)], MCont (f, vs))))
             else
               (l, vs, m)
            )
            ls,
          add_landing_lambdas m)

Complex loop header set:
:   $\{$ `l`$_1, \dots,$ `l`$_n \}$ is a complex loop header set
